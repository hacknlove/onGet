{"version":3,"sources":["webpack://onGet/webpack/universalModuleDefinition","webpack://onGet/webpack/bootstrap","webpack://onGet/./plugins/fetch.js","webpack://onGet/./plugins/localstorage.js","webpack://onGet/./plugins/sessionstorage.js","webpack://onGet/./plugins/state.js","webpack://onGet/./src/addNewSubscription.js","webpack://onGet/./src/clean.js","webpack://onGet/./src/conf.js","webpack://onGet/./src/createUnsubscribe.js","webpack://onGet/./src/findPlugin.js","webpack://onGet/./src/get.js","webpack://onGet/./src/getEndpoint.js","webpack://onGet/./src/index.js","webpack://onGet/./src/onGet.js","webpack://onGet/./src/pospone.js","webpack://onGet/./src/refresh.js","webpack://onGet/./src/registerPlugin.js","webpack://onGet/./src/set.js","webpack://onGet/external {\"commonjs\":\"@hacknlove/deepobject\",\"commonjs2\":\"@hacknlove/deepobject\",\"amd\":\"@hacknlove/deepobject\",\"root\":\"deepObject\"}","webpack://onGet/external {\"commonjs\":\"isdifferent\",\"commonjs2\":\"isdifferent\",\"amd\":\"isdifferent\",\"root\":\"isDifferent\"}"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,QAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;;AAEe,qEAAM;;;;;;;;;;;;;AChBrB;AAAA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC1BD;AAAA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC1BD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0D;AACrB;AACE;;AAEvC;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA,mBAAmB,mDAAS;;AAE5B;AACA,qBAAqB,sEAAQ;AAC7B;AACA;AACA;AAC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","file":"onGet.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@hacknlove/deepobject\"), require(\"isdifferent\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"onGet\", [\"@hacknlove/deepobject\", \"isdifferent\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"onGet\"] = factory(require(\"@hacknlove/deepobject\"), require(\"isdifferent\"));\n\telse\n\t\troot[\"onGet\"] = factory(root[\"deepObject\"], root[\"isDifferent\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__hacknlove_deepobject__, __WEBPACK_EXTERNAL_MODULE_isdifferent__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","/* global fetch */\n\nconst plugin = {\n  name: 'fetch',\n  regex: /^./,\n  checkInterval: 30000,\n  threshold: 500,\n  async refresh (endpoint, eventHandler) {\n    const response = await fetch(endpoint.url).catch(error => ({ error }))\n    if (response.error) {\n      return eventHandler(response.error)\n    }\n    eventHandler(await response.json().catch(async () => response.text()))\n  }\n}\n\nexport default plugin\n","/* global localStorage */\nconst PROTOCOLCUT = 'localStorage://'.length\n\nexport default {\n  name: 'localStorage',\n  regex: /^localStorage:\\/\\/./i,\n  checkInterval: 30000,\n  threshold: 500,\n  refresh (endpoint, eventHandler) {\n    eventHandler(localStorage[endpoint.key])\n  },\n  getEndpoint (endpoint) {\n    endpoint.key = endpoint.url.substr(PROTOCOLCUT)\n\n    if (localStorage[endpoint.key] !== undefined) {\n      endpoint.value = localStorage[endpoint.key]\n      return\n    }\n    localStorage[endpoint.key] = endpoint.value\n  },\n  get (url) {\n    return localStorage[url.substr(PROTOCOLCUT)]\n  },\n  set (endpoint) {\n    localStorage[endpoint.key] = endpoint.value\n  }\n}\n","/* global sessionStorage */\nconst PROTOCOLCUT = 'sessionStorage://'.length\n\nexport default {\n  name: 'sessionStorage',\n  regex: /^sessionStorage:\\/\\/./i,\n  checkInterval: 30000,\n  threshold: 500,\n  refresh (endpoint, eventHandler) {\n    eventHandler(sessionStorage[endpoint.key])\n  },\n  getEndpoint (endpoint) {\n    endpoint.key = endpoint.url.substr(PROTOCOLCUT)\n\n    if (sessionStorage[endpoint.key] !== undefined) {\n      endpoint.value = sessionStorage[endpoint.key]\n      return\n    }\n    sessionStorage[endpoint.key] = endpoint.value\n  },\n  get (url) {\n    return sessionStorage[url.substr(PROTOCOLCUT)]\n  },\n  set (endpoint) {\n    sessionStorage[endpoint.key] = endpoint.value\n  }\n}\n","import { getValue, setValue } from '@hacknlove/deepobject'\nimport isDifferent from 'isdifferent'\nimport { endpoints } from '../src/conf'\n\nvar state = {}\n\n/**\n * For each endpoint whose url is a parent of url, update his value and call his callbacks\n *\n * state://foo.bar is a parent of state://foo.bar.buz\n * @param {string} url\n * @returns {undefined}\n */\nexport function propagateUp (url) {\n  const parentUrl = url.replace(/\\.?[^.]*$/, '')\n  if (!parentUrl) {\n    return\n  }\n  const endpoint = endpoints[parentUrl]\n\n  if (endpoint) {\n    endpoint.value = getValue(state, endpoint.url)\n    Object.values(endpoint.callbacks).forEach(cb => setTimeout(cb, 0, endpoint.value))\n  }\n  setTimeout(propagateUp, 0, parentUrl)\n}\n\n/**\n * For each endpoint whose url is a child of url, if his value has changed, update it and call his callbacks\n *\n * state://foo.bar.buz is a parent of state://foo.bar\n * @param {string} url\n * @returns {undefined}\n */\nexport function propagateDown (url) {\n  const parent = endpoints[url]\n  const prefix = `${url}.`\n  Object.keys(endpoints).forEach(childUrl => {\n    if (!childUrl.startsWith(prefix)) {\n      return\n    }\n    const child = endpoints[childUrl]\n    const newChildValue = getValue(parent.value, childUrl.substr(url.length + 1))\n\n    if (isDifferent(newChildValue, child.value)) {\n      child.value = newChildValue\n      Object.values(child.callbacks).forEach(cb => setTimeout(cb, 0, newChildValue))\n    }\n  })\n}\n\nexport default {\n  name: 'state',\n  regex: /^state:\\/\\/./,\n\n  /**\n   * Nothing to refresh. shows a warning in the console\n   * @returns {undefined}\n   */\n  refresh () {\n    console.warn('the true source for this plugin is client side, so refresh does nothing')\n  },\n\n  /**\n   * If the state has not value for this endpoint.url, creates a new updated state\n   * else, set endpoint.value according to the state\n   * @param {object} endpoint\n   */\n  getEndpoint (endpoint) {\n    const actualValue = getValue(state, endpoint.url)\n    if (actualValue === undefined) {\n      state = setValue(state, endpoint.url, endpoint.value)\n      propagateUp(endpoint.url)\n      propagateDown(endpoint.url)\n      return\n    }\n    endpoint.value = actualValue\n  },\n\n  /**\n   * Returns the value at the state\n   * @param {string} url\n   * @returns {object} the value\n   */\n  get (url) {\n    return getValue(state, url)\n  },\n\n  /**\n   * Updates the endpoint.value, and propagates up and down\n   * @params {object} endpoint\n   * @returns {undefined}\n   */\n  set (endpoint) {\n    state = setValue(state, endpoint.url, endpoint.value)\n    propagateUp(endpoint.url)\n    propagateDown(endpoint.url)\n  },\n\n  /**\n   * If there is no children endpoint, delete the value, and propagate up\n   * @param {object} endpoint\n   * @returns {undefined}\n   */\n  clean (endpoint) {\n    const prefix = `${endpoint.url}.`\n    if (Object.keys(endpoints).some(url => url.startsWith(prefix))) {\n      return\n    }\n    propagateUp(endpoint.url)\n  }\n}\n","import { endpoints } from './conf'\nimport { createUnsubscribe } from './createUnsubscribe'\n\n/**\n * Adds the callback to the endpoint, updates the min interval configuration, and returns the unsubscribe function\n * @param {string} url endpoint's url\n * @param {function} callback it will be called each time the value of the endpoint changes\n * @param {number} [interval] max interval (milliseconds) to check for a new value\n * @return {function} unsubscribe function\n */\nexport function addNewSubscription (url, callback, interval) {\n  const endpoint = endpoints[url]\n\n  var sk\n  do {\n    sk = Math.random().toString(36).substr(2) + (Date.now() % 1000).toString(36)\n  } while (endpoint.callbacks[sk])\n  endpoint.callbacks[sk] = callback\n\n  if (endpoint.intervals) {\n    interval = interval || endpoint.plugin.checkInterval\n    endpoint.intervals[sk] = interval\n    endpoint.minInterval = Math.min(endpoint.minInterval, interval)\n  }\n\n  return createUnsubscribe(endpoint, sk)\n}\n","import { conf, endpoints } from './conf'\n\n/**\n * Cleans unused endpoints. The ones that has no callbacks, no method called recently.\n * It is  intended to be called each time a new endpoint is created\n */\nexport function clean () {\n  const values = Object.values(endpoints)\n\n  if (values.length < conf.CACHE_SIZE) {\n    return\n  }\n\n  values.forEach(endpoint => {\n    if (!endpoint.clean) {\n      if (Object.keys(endpoint.callbacks).length === 0) {\n        endpoint.clean = true\n      }\n      return\n    }\n    if (endpoint.plugin.clean && endpoint.plugin.clean(endpoint)) {\n      return\n    }\n    clearTimeout(endpoints[endpoint.url].timeout)\n    delete endpoints[endpoint.url]\n  })\n}\n","export const conf = {\n  CACHE_SIZE: 100\n}\nexport const endpoints = {}\nexport const plugins = []\n","/**\n * Function factory that creats and returns unsubscribe functions\n * @param {object} endpoint from which unsubscribe\n * @param {strink} sk key that identifies the subscription\n */\nexport function createUnsubscribe (endpoint, sk) {\n  return () => {\n    if (!endpoint.callbacks.hasOwnProperty(sk)) {\n      return\n    }\n\n    delete endpoint.callbacks[sk]\n    if (endpoint.intervals) {\n      delete endpoint.intervals[sk]\n      endpoint.minInterval = Math.min(...Object.values(endpoint.intervals))\n    }\n  }\n}\n","import { plugins } from './conf'\n\n/**\n * Internal: Returns the first plugin whose regex matchs the url\n * @param {string} url endpoint's url\n * @return plugin object\n */\nexport function findPlugin (url) {\n  return plugins.find(plugin => url.match(plugin.regex))\n}\n","import { findPlugin } from './findPlugin'\nimport { endpoints } from './conf'\n\n/**\n * Returns the cached value for the endpoint\n * @param {string} url url of the endpoint\n * @param {boolean} onlyCached=true, set to false to force the plugin to obtain a value if none if cached\n * @returns {any} whatever value is cached, or undefined, (or the obtained value if onlyCached = false)\n */\nexport function get (url) {\n  const endpoint = endpoints[url]\n  if (endpoint) {\n    endpoint.clean = undefined\n    return endpoints[url].value\n  }\n  const plugin = findPlugin(url)\n  if (!plugin.get) {\n    return undefined\n  }\n  return plugin.get(url)\n}\n","import { findPlugin } from './findPlugin'\nimport { endpoints } from './conf'\nimport { clean } from './clean'\n\n/**\n * Creates if needed and returns the object that stores the callbacks, configuration and state of an endpoint\n * @param {string} url endpoint's url\n * @params {any} [firstValue] is used as a firstValue, before any action was performed by the plugin\n * @returns {object} the endpoint\n */\nexport function getEndpoint (url, firstValue) {\n  if (endpoints[url]) {\n    return endpoints[url]\n  }\n  setTimeout(clean)\n  const plugin = findPlugin(url)\n  if (!plugin) {\n    throw new Error(`No plugin for ${url}`)\n  }\n  const endpoint = {\n    url,\n    plugin,\n    value: firstValue,\n    callbacks: {}\n  }\n  endpoints[url] = endpoint\n\n  if (plugin.checkInterval) {\n    endpoint.intervals = {}\n    endpoint.minInterval = Infinity\n  }\n\n  if (plugin.threshold !== undefined) {\n    endpoint.last = -Infinity\n  }\n\n  if (plugin.getEndpoint) {\n    plugin.getEndpoint(endpoint)\n  }\n\n  return endpoint\n}\n","import { onGet } from './onGet'\nimport { set } from './set'\nimport { refresh } from './refresh'\nimport { get } from './get'\nimport { conf, endpoints, plugins } from './conf'\nimport { registerPlugin } from './registerPlugin'\n\nimport fetch from '../plugins/fetch'\nimport localStorage from '../plugins/localstorage'\nimport sessionStorate from '../plugins/sessionstorage'\nimport state from '../plugins/state'\n\nregisterPlugin(fetch)\nregisterPlugin(localStorage)\nregisterPlugin(sessionStorate)\nregisterPlugin(state)\n\nexport {\n  onGet, set, refresh, get, registerPlugin, conf, endpoints, plugins\n}\n","import { getEndpoint } from './getEndpoint'\nimport { addNewSubscription } from './addNewSubscription'\nimport { refresh } from './refresh'\n\n/**\n * Set a handler to be called each time the value of the url changes\n * @param {string} url The value to subscribe to\n * @param {function} cb handler to be called\n * @param {object} options Optional parameters\n * @param {integer} options.interval seconds to refresh the value\n * @param {any} options.first first value to pass to the plugin\n */\nexport function onGet (url, cb, options = {}) {\n  const {\n    first,\n    interval\n  } = options\n  const endpoint = getEndpoint(url, first)\n\n  const unsubscribe = addNewSubscription(url, cb, interval)\n  endpoint.clean = undefined\n\n  if (endpoint.value !== undefined) {\n    cb(endpoint.value)\n  }\n  if (Date.now() - endpoint.last > endpoint.plugin.threshold) {\n    refresh(url)\n  }\n  return unsubscribe\n}\n","import { endpoints } from './conf'\nimport { refresh } from './refresh'\n/**\n * Pospone the refresh of the endpoint\n * @param {object} endpoint endpoint whose refresh should be posponed, as returned by getEndpoint(url)\n * @returns undefined\n */\nexport function pospone (endpoint) {\n  if (!endpoint.intervals) {\n    return\n  }\n  clearTimeout(endpoint.timeout)\n  if (!endpoints[endpoint.url]) {\n    return\n  }\n  endpoint.last = Date.now()\n  endpoint.timeout = setTimeout(() => {\n    refresh(endpoint.url)\n  }, endpoint.minInterval)\n}\n","import { endpoints } from './conf'\nimport { set } from './set'\nimport { pospone } from './pospone'\n\n/**\n * Obtain the current value and is different, update the cache and call the handlers\n * @param {string} url of the endpoints to be refreshed\n * @returns {boolean} False if there is nothing to refresh, true otherwise\n */\nexport function refresh (url) {\n  const endpoint = endpoints[url]\n  if (!endpoint) {\n    return false\n  }\n  endpoint.clean = undefined\n  if (endpoint.plugin.threshold !== undefined && Date.now() - endpoint.last < endpoint.plugin.threshold) {\n    return\n  }\n  pospone(endpoint)\n  endpoint.plugin.refresh(endpoint, value => {\n    set(url, value)\n  })\n  return true\n}\n","import { plugins } from './conf'\n\n/**\n * Registers a plugin. Plugins are checked last registered first checked.\n * @param {object} plugin Plugin object to register\n * @param {string} plugin.name Name of the plugin, not really used\n * @param {RegExp} plugin.regex Regex to match the endpoint's url\n * @param {number} plugin.checkInterval amount of milliseconds to call refresh,\n * @param {number} plugin.threshold amount of millisecons in which a subsecuent call to get, or onGet, uses the cached value instead of calling refresh\n * @param {function} plugin.refresh function that is called to obtain the value\n * @returns {undefined} undefined\n */\nexport function registerPlugin (plugin) {\n  plugins.unshift(plugin)\n}\n","import isDifferent from 'isdifferent'\nimport { endpoints } from './conf'\nimport { getEndpoint } from './getEndpoint'\nimport { pospone } from './pospone'\n/**\n * set a new cached value for an endpoint, and call the handlers. If the endpoint does not exists, it creates it.\n * @param {string} url  of the endpoint whose value set to\n * @param {any} value value to series\n * @param {boolean} doPospone=true if false do not pospone the closest refresh\n * @return {object} endpoint\n */\n\nexport function set (url, value, doPospone) {\n  const endpoint = endpoints[url]\n\n  if (!endpoint) {\n    const endpoint = getEndpoint(url, value)\n    if (endpoint.plugin.set) {\n      endpoint.value = value\n      endpoint.plugin.set(endpoint)\n    }\n    return\n  }\n\n  endpoint.clean = undefined\n  if (endpoint.intervals && doPospone) {\n    pospone(endpoint)\n  }\n  if (!isDifferent(value, endpoint.value)) {\n    return\n  }\n\n  endpoint.value = value\n  if (endpoint.plugin.set) {\n    endpoint.plugin.set(endpoint)\n  }\n\n  Object.values(endpoint.callbacks).forEach(cb => setTimeout(cb, 0, endpoint.value))\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__hacknlove_deepobject__;","module.exports = __WEBPACK_EXTERNAL_MODULE_isdifferent__;"],"sourceRoot":""}